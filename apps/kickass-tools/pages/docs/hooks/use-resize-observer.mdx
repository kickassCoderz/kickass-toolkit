import { UseResizeObserverExampleBasic } from '../../../examples/hooks'
import { DocsLayout } from '../../../components'

export const meta = {
    title: 'useResizeObserver',
    description: "Invokes a callback whenever ResizeObserver detects a change to target's size."
}

[Back to Hooks](/docs/hooks)

# {meta.title}

<p>{meta.description}</p>

-   Uses a single `ResizeObserver` for all hook instances, as it is more effective than using per-hook observers.
-   No need to wrap callback with `useCallback`, because hook manages callback mutation internally.
-   Does not apply any throttle or debounce mechanism - it is on end-developer side.
-   Does not produce references for you.
-   SSR friendly.
-   Provides access to `ResizeObserverEntry`.
-   Allows to dynamically enable and disable observation.

## Basic usage

<UseResizeObserverExampleBasic />

```jsx
import { useResizeObserver } from '@kickass-coderz/hooks'
import { styled } from '@stitches/react'
import { useRef } from 'react'

const Box = styled('div', {
    width: 200,
    height: 200,
    background: 'hotpink',
    resize: 'both',
    overflow: 'hidden',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
})

const UseResizeObserverExampleBasic = () => {
    const elementRef = useRef()

    useResizeObserver({
        target: elementRef,
        onResize({ contentRect }) {
            elementRef.current.innerHTML = `
             width: ${contentRect.width}
             height: ${contentRect.height}
             `
        }
    })

    return <Box ref={elementRef} />
}
```

export default ({ children }) => <DocsLayout meta={meta}>{children}</DocsLayout>
