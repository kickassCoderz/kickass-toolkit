import { UseResizeObserverExampleBasic } from '../../../examples/hooks'
import { DocsLayout } from '../../../components'

export const meta = {
    title: 'useResizeObserver',
    description: "Invokes a callback whenever ResizeObserver detects a change to target's size."
}

[Back to Hooks](/docs/hooks)

# {meta.title}

<p>{meta.description}</p>

-   Uses a single `ResizeObserver` for all hook instances, as it is more effective than using per-hook observers.
-   No need to wrap callback with `useCallback`, because hook manages callback mutation internally.
-   Does not apply any throttle or debounce mechanism - it is on end-developer side.
-   Does not produce references for you.
-   SSR friendly.
-   Provides access to `ResizeObserverEntry`.
-   Allows to dynamically enable and disable observation.

## Basic usage

<UseResizeObserverExampleBasic />

```jsx
import { useRef } from 'react'
import { useResizeObserver } from '@kickass-coderz/hooks'

const UseResizeObserverExampleBasic = () => {
    const elementRef = useRef()

    useResizeObserver({
        target: elementRef.current,
        onResize(entry) {
            console.log(entry)
        }
    })

    return (
        <div
            ref={elementRef}
            style={{ width: 200, height: 200, background: 'blue', resize: 'both', overflow: 'hidden' }}
        ></div>
    )
}
```

export default ({ children }) => <DocsLayout meta={meta}>{children}</DocsLayout>
